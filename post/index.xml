<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Post-rsses on Beppu&#39;s Blog</title>
    <link>http://beppu.github.io/post/index.xml</link>
    <description>Recent content in Post-rsses on Beppu&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 19 Oct 2016 09:20:15 -0700</lastBuildDate>
    <atom:link href="http://beppu.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Why I Chose Hugo</title>
      <link>http://beppu.github.io/post/why-i-chose-hugo/</link>
      <pubDate>Wed, 19 Oct 2016 09:20:15 -0700</pubDate>
      
      <guid>http://beppu.github.io/post/why-i-chose-hugo/</guid>
      <description>

&lt;h3 id=&#34;why-did-you-pick-hugo-and-go-instead-of-github-s-jekyll&#34;&gt;Why did you pick hugo (and Go) instead of github&amp;rsquo;s jekyll?&lt;/h3&gt;

&lt;p&gt;I was initially going to use Jekyll, but when I tried to do a &lt;code&gt;bundle install&lt;/code&gt;, one of the dependencies failed to install.  I didn&amp;rsquo;t feel like fighting that battle, so I decided to try Hugo instead since I had looked at it in the past.&lt;/p&gt;

&lt;p&gt;What I liked about Hugo was that:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;it was fast,&lt;/li&gt;
&lt;li&gt;it had a nice selection of &lt;strong&gt;&lt;a href=&#34;http://themes.gohugo.io/&#34;&gt;themes&lt;/a&gt;&lt;/strong&gt;,&lt;/li&gt;
&lt;li&gt;its blogging functionality was adequate.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As for Go, it wasn&amp;rsquo;t a major factor in choosing a static site generator for me.&lt;/p&gt;

&lt;h3 id=&#34;how-proficient-you-need-to-be-in-go-to-use-hugo&#34;&gt;How proficient you need to be in Go to use Hugo?&lt;/h3&gt;

&lt;p&gt;You don&amp;rsquo;t need to know Go at all, and I haven&amp;rsquo;t even looked at a line of Hugo&amp;rsquo;s Go code yet.&lt;/p&gt;

&lt;p&gt;However, what you do need is some proficiency with the Unix shell so that you can run the various &lt;code&gt;hugo&lt;/code&gt; commands and navigate the directory structure it generates for you.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s also helpful for when things go wrong and you need to debug.  For example, this &lt;strong&gt;&lt;a href=&#34;http://themes.gohugo.io/future-imperfect/&#34;&gt;theme&lt;/a&gt;&lt;/strong&gt; that I&amp;rsquo;m using was slightly buggy out of the box, and I had to move some files around to make it work.&lt;/p&gt;

&lt;h3 id=&#34;did-you-try-other-static-site-generators&#34;&gt;Did you try other static site generators?&lt;/h3&gt;

&lt;p&gt;I did go over to &lt;a href=&#34;https://www.staticgen.com/&#34;&gt;https://www.staticgen.com/&lt;/a&gt; and look over the list.  I remembered that Hugo was one of the ones you liked, so I gave that a try first, and I liked it.  Thus, the search ended rather quickly.&lt;/p&gt;

&lt;h3 id=&#34;your-thoughts-on-storing-comments-on-your-own&#34;&gt;Your thoughts on storing comments on your own&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;(it&amp;rsquo;d probably require a dynamic site, though I saw some weird IMAP tricks with Pelican a while ago) vs using something like Disqus.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;On blogs where the topic matter makes censorship unlikely, I don&amp;rsquo;t mind delegating comments to a system like Disqus.  If I were running a blog with political commentary, I would definitely want to handle comments locally, though.&lt;/p&gt;

&lt;p&gt;To be honest, I was actually surprised when I saw the Disqus comment widget when I published it to GitHub, because they didn&amp;rsquo;t show up at all while I was developing the site locally.  It&amp;rsquo;s using someone else&amp;rsquo;s generic Disqus forum and not one that I set up myself.&lt;/p&gt;

&lt;p&gt;&lt;del&gt;I should probably fix that.&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;I fixed it &amp;ndash; I have my own disqus forum now.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>On Choosing Frameworks</title>
      <link>http://beppu.github.io/post/on-choosing-frameworks/</link>
      <pubDate>Tue, 18 Oct 2016 14:50:07 -0700</pubDate>
      
      <guid>http://beppu.github.io/post/on-choosing-frameworks/</guid>
      <description>&lt;p&gt;A friend of mine who is an experienced systems programmer was working on familiarizing himself with web development, and he was overwhelmed by all the choices he had to make.  This was my advice to him:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The explosion of frameworks is a headache for everyone, but you don&amp;rsquo;t have to know all of them, because no one does.  You&amp;rsquo;re just going to have to pick a couple and go with them for a while.&lt;/p&gt;

&lt;p&gt;On the server side, there are many adequate frameworks these days.  What you should pick is largely determined by what server side language you&amp;rsquo;re comfortable with.  This filter reduces the size of the list considerably.  Then, from what&amp;rsquo;s left, pick a framework that is actively being maintained and has good documentation.  As long as they give you good control over HTTP requests and responses, you&amp;rsquo;re good to go.  It&amp;rsquo;s hard to go wrong here, because almost anything can be made to work adequately &amp;ndash; HTTP servers are well understood today.&lt;/p&gt;

&lt;p&gt;On the client side, there were two major eras of library wars so far.  In the mid to late 2000s, there was a battle between Prototype, jQuery, and a bunch of other Javascript utility libraries.  jQuery was the winner of that era, and it would be good to have basic familiarity with jQuery even though it&amp;rsquo;s gone out of fashion now.&lt;/p&gt;

&lt;p&gt;The second major library war on the client side was waged between Backbone, Angular, React, and many others &amp;ndash; too many to name.  This war started in the early 2010s, and it is ongoing, but I believe the winner is React.js.  It has many good qualities going for it, but it is also very different from anything that came before it.&lt;/p&gt;

&lt;p&gt;This blog post on React.js was probably the turning point that made a lot of people start taking it seriously.  &lt;a href=&#34;http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs&#34;&gt;http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;It showed that React.js could be extremely performant while also promoting a style of programming that made client-side UI behavior a lot more predictable than it had been in the past.  (Believe me, it was (and sometimes still is) a mess.)&lt;/p&gt;

&lt;p&gt;Another big plus for React.js is that it can be used to develop native Android and iOS applications which few other libraries can claim.  Perhaps no other library can do this, because the main idea behind React.js is to represent your UI as a pure function, and this is a broad idea that isn&amp;rsquo;t confined to just HTML.  This makes it special among the client side libraries.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s downside (if you could call it that) is that the Facebook engineers who made it are fond of source code transformers, so you&amp;rsquo;re development setup will need to have tools like WebPack, Babel, sometimes Flow, etc&amp;hellip;  configured.  That&amp;rsquo;s a god damned headache, but such is life in the web development world.  Hopefully, you only have to set it up once in the beginning and not worry about it later, but I find it annoying to need all these tools.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
  </channel>
</rss>